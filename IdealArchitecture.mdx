Great question! Let me design how I would architect Toronto Pulse from the ground up with scalability, maintainability, and rapid data source addition as primary concerns.

## **Ideal Architecture from Scratch**

### 1. **Domain-Driven Design with Clear Boundaries**

```
src/
├── domains/                    # Business domains
│   ├── transportation/         # Transit, bike share, etc.
│   ├── infrastructure/         # Roads, utilities, construction
│   ├── environment/           # Air quality, beaches, parks
│   ├── events/               # Festivals, closures, incidents
│   └── demographics/         # Population, economic data
├── core/                     # Shared kernel
│   ├── data-sources/         # Generic data source system
│   ├── mapbox/              # Map-specific logic
│   ├── ui/                  # Reusable UI components
│   └── utils/               # Shared utilities
├── infrastructure/           # External concerns
│   ├── apis/                # API clients and adapters
│   ├── cache/               # Caching strategies
│   └── config/              # Environment and feature flags
└── app/                     # Application layer
    ├── components/          # App-specific components
    ├── hooks/              # App-specific hooks
    └── store/              # Global state management
```

### 2. **Plugin-Based Data Source System**

Every data source would be a self-contained plugin:

```typescript
// core/data-sources/types.ts
interface DataSourcePlugin {
  metadata: DataSourceMetadata;
  fetcher: DataFetcher;
  transformer: DataTransformer;
  validator: DataValidator;
  cache?: CacheStrategy;
}

interface DataSourceMetadata {
  id: string;
  name: string;
  domain: string;
  version: string;
  author: string;
  description: string;
  tags: string[];
  refreshInterval: number;
  reliability: 'high' | 'medium' | 'low';
  dataLicense: string;
  apiDocumentationUrl?: string;
}
```

### 3. **Configuration-First Approach**

```typescript
// data-sources/ttc-vehicles/config.json
{
  "metadata": {
    "id": "ttc-vehicles",
    "name": "TTC Live Vehicles",
    "domain": "transportation",
    "version": "1.0.0",
    "refreshInterval": 30000,
    "reliability": "high"
  },
  "api": {
    "type": "xml",
    "baseUrl": "https://webservices.umoiq.com/service/publicXMLFeed",
    "authentication": null,
    "rateLimit": {
      "requests": 60,
      "window": 60000
    }
  },
  "transform": {
    "strategy": "xml-to-geojson",
    "mappings": {
      "latitude": "$.vehicle.@lat",
      "longitude": "$.vehicle.@lon",
      "id": "$.vehicle.@id"
    }
  },
  "visualization": {
    "layer": {
      "type": "circle",
      "paint": {
        "circle-radius": 6,
        "circle-color": "#dc2626"
      }
    },
    "popup": {
      "template": "ttc-vehicle-popup"
    }
  }
}
```

### 4. **Generic Data Source Registry**

```typescript
// core/data-sources/registry.ts
class DataSourceRegistry {
  private sources = new Map<string, DataSourcePlugin>();
  
  async loadFromDirectory(path: string): Promise<void> {
    // Auto-discover and load all data source plugins
  }
  
  async loadFromConfig(config: DataSourceConfig): Promise<void> {
    // Load individual data source from configuration
  }
  
  register(plugin: DataSourcePlugin): void {
    this.sources.set(plugin.metadata.id, plugin);
  }
  
  getByDomain(domain: string): DataSourcePlugin[] {
    return Array.from(this.sources.values())
      .filter(source => source.metadata.domain === domain);
  }
  
  getByTags(tags: string[]): DataSourcePlugin[] {
    return Array.from(this.sources.values())
      .filter(source => 
        tags.some(tag => source.metadata.tags.includes(tag))
      );
  }
}
```

### 5. **Standardized Data Source Structure**

Each data source would be a complete module:

```
data-sources/
├── ttc-vehicles/
│   ├── config.json              # Metadata and configuration
│   ├── fetcher.ts               # How to get the data
│   ├── transformer.ts           # How to convert to GeoJSON
│   ├── validator.ts             # How to validate the data
│   ├── popup-template.tsx       # How to display in popup
│   ├── README.md               # Documentation
│   ├── test.spec.ts            # Tests
│   └── index.ts                # Plugin entry point
├── bike-share-toronto/
│   ├── config.json
│   ├── fetcher.ts
│   └── ...
└── toronto-beaches/
    ├── config.json
    ├── fetcher.ts
    └── ...
```

### 6. **Universal Data Transformers**

```typescript
// core/data-sources/transformers/
export const transformers = {
  'xml-to-geojson': new XMLToGeoJSONTransformer(),
  'csv-to-geojson': new CSVToGeoJSONTransformer(),
  'json-to-geojson': new JSONToGeoJSONTransformer(),
  'gtfs-realtime': new GTFSRealtimeTransformer(),
  'toronto-open-data': new TorontoOpenDataTransformer(),
  'socrata': new SOCRATATransformer(),
  'ckan': new CKANTransformer(),
  'gbfs': new GBFSTransformer(),
};

// Custom transformers for unique APIs
export const customTransformers = {
  'ttc-xml': new TTCXMLTransformer(),
  'weather-canada': new WeatherCanadaTransformer(),
};
```

### 7. **Smart Caching System**

```typescript
// core/cache/strategies.ts
interface CacheStrategy {
  key: string;
  ttl: number;
  invalidationRules: InvalidationRule[];
  storage: 'memory' | 'indexeddb' | 'localstorage';
}

export const cacheStrategies = {
  'real-time': {
    ttl: 30000,
    storage: 'memory',
    invalidationRules: ['on-error', 'on-stale']
  },
  'semi-static': {
    ttl: 300000,
    storage: 'indexeddb',
    invalidationRules: ['daily', 'on-version-change']
  },
  'static': {
    ttl: 86400000,
    storage: 'indexeddb',
    invalidationRules: ['weekly']
  }
};
```

### 8. **Feature Flag System**

```typescript
// infrastructure/config/features.ts
interface FeatureFlag {
  key: string;
  enabled: boolean;
  rolloutPercentage?: number;
  conditions?: Condition[];
}

export const featureFlags = {
  'data-source-ttc-vehicles': { enabled: true },
  'data-source-bike-share': { enabled: true },
  'experimental-weather-layer': { 
    enabled: true, 
    rolloutPercentage: 50 
  },
  'beta-traffic-predictions': { 
    enabled: false 
  }
};
```

### 9. **CLI Tools for Development**

```bash
# Generate new data source scaffold
npx toronto-pulse generate:datasource --name="Toronto Parking" --domain="infrastructure"

# Test data source
npx toronto-pulse test:datasource --source="ttc-vehicles" --validate

# Add existing Toronto Open Data dataset
npx toronto-pulse add:dataset --url="https://open.toronto.ca/dataset/xyz" --auto-configure

# Deploy data source
npx toronto-pulse deploy:datasource --source="bike-share" --environment="production"

# Validate all data sources
npx toronto-pulse validate:all

# Generate documentation
npx toronto-pulse docs:generate
```

### 10. **Type-Safe Configuration Schema**

```typescript
// Use Zod for runtime validation and TypeScript generation
import { z } from 'zod';

const DataSourceConfigSchema = z.object({
  metadata: z.object({
    id: z.string(),
    name: z.string(),
    domain: z.enum(['transportation', 'infrastructure', 'environment', 'events']),
    version: z.string(),
    refreshInterval: z.number().min(1000),
    reliability: z.enum(['high', 'medium', 'low']),
  }),
  api: z.object({
    type: z.enum(['json', 'xml', 'csv', 'gtfs', 'custom']),
    baseUrl: z.string().url(),
    authentication: z.optional(z.object({
      type: z.enum(['apikey', 'oauth', 'basic']),
      config: z.record(z.string())
    }))
  }),
  transform: z.object({
    strategy: z.string(),
    mappings: z.record(z.string())
  })
});

export type DataSourceConfig = z.infer<typeof DataSourceConfigSchema>;
```

### 11. **Observability from Day One**

```typescript
// core/observability/
interface DataSourceMetrics {
  sourceId: string;
  fetchCount: number;
  errorCount: number;
  avgResponseTime: number;
  lastSuccessfulFetch: Date;
  dataQualityScore: number;
}

class DataSourceMonitor {
  trackFetch(sourceId: string, duration: number, success: boolean): void;
  trackDataQuality(sourceId: string, score: number): void;
  getHealthStatus(sourceId: string): HealthStatus;
  generateReport(): DataSourceReport;
}
```

## **Key Architectural Decisions**

### 1. **Domain-Driven Design**
- Organize by business domains, not technical layers
- Each domain can evolve independently
- Clear boundaries reduce coupling

### 2. **Plugin Architecture**
- Data sources are self-contained plugins
- No code changes needed to add new sources
- Easy to disable/enable sources

### 3. **Configuration Over Code**
- Most data sources defined in JSON
- Runtime reconfiguration possible
- Non-developers can add simple data sources

### 4. **Schema-First Development**
- Define data contracts upfront
- Runtime validation with Zod
- Auto-generated TypeScript types

### 5. **Observable by Default**
- Every data source has metrics
- Health monitoring built-in
- Performance tracking included

## **Benefits of This Architecture**

### **For Adding New Data Sources:**
1. **Simple sources**: Just add a config file
2. **Complex sources**: Scaffold with CLI, implement 3 functions
3. **No core code changes** needed for most additions
4. **Automatic testing** and validation

### **For Maintenance:**
1. **Clear separation** of concerns
2. **Independent deployments** of data sources
3. **Easy debugging** with built-in observability
4. **Self-documenting** configuration

### **For Scale:**
1. **Horizontal scaling** - add data sources without architectural changes
2. **Performance isolation** - slow data sources don't affect others
3. **Gradual rollouts** with feature flags
4. **Easy deprecation** of old sources

## **Implementation Timeline**

If building from scratch with this architecture:

- **Week 1-2**: Core plugin system and registry
- **Week 3**: First data source (TTC) with full pipeline
- **Week 4**: CLI tools and scaffolding
- **Week 5-6**: Add 3-4 more data sources to validate architecture
- **Week 7**: Observability and monitoring
- **Week 8**: Documentation and testing

**After this foundation**, adding new data sources would typically take:
- **Simple sources**: 30 minutes to 2 hours
- **Complex sources**: 1-2 days
- **New domains**: 2-3 days

This architecture would make Toronto Pulse incredibly scalable - you could easily have 50+ data sources without the complexity becoming unmanageable.